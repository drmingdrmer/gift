#!/usr/bin/env python3
# coding: utf-8

import select
import os
import subprocess
import sys
import pty

import yaml

if hasattr(sys, 'getfilesystemencoding'):
    defenc = sys.getfilesystemencoding()
if defenc is None:
    defenc = sys.getdefaultencoding()

conffn = ".gift"
refsfn = ".gift-refs"
superref = "refs/remotes/super/head"

verbose = False
# verbose = True


def dd(*msg):
    if not verbose:
        return
    os.write(2, b">>> ")
    for m in msg:
        os.write(2, _bytes(m))
        os.write(2, b" ")
    os.write(2, b"\n")


def _out(f, line):
    os.write(f, _bytes(line))
    os.write(f, b"\n")


def pj(*args):
    return os.path.join(*args)

def pabs(*args):
    p = os.path.abspath(pj(*args))
    return os.path.normpath(p)

class GiftError(Exception):
    def __init__(self, msg):
        super(GiftError, self).__init__(msg)
        self.returncode = 2
        self.out=[]
        self.err = [msg]


class Gift(object):
    """
    """

    # inside gitdir:
    sub_gitdir_fmt = "gift/subdir/{dir}"

    def __init__(self, startpath, opt, gitpath=None):
        self.startpath = startpath
        self.opt = opt
        self.cwd = pabs(".")
        self.gitpath = gitpath or "git"
        self.in_git_dir = False


    def init_git_config(self):

        self.git_dir = cmd0(self.gitpath, "rev-parse", "--git-dir", cwd=self.cwd)
        self.git_dir = pabs(self.git_dir)
        dd("git_dir:", self.git_dir)

        if (self.cwd.startswith(self.git_dir + '/')
            or self.git_dir == self.cwd):
            self.in_git_dir = True

        if self.in_git_dir:
            return

        # TODO test non git dir
        self.working_dir = cmd0(self.gitpath, "rev-parse", "--show-toplevel", cwd=self.cwd)
        # TODO test working_dir
        dd("working_dir:", self.working_dir)

        self.confpath = self.working_dir + '/' + conffn
        self.conf = self.parse()

    def parse_remote(self, subdir, remo):
        # TODO use regex to detect

        # TODO test this:
        # There is a @ in it
        # gift clone --sub ssh://git@github.com/openacid/celeritasdb.wiki wiki

        elts = remo.rsplit("@", 1)
        # if len(elts) == 1:
        #     elts.append("master")
        return ["origin", elts[0], elts[1]]


    def read_conf(self):
        try:
            with open(self.confpath, 'r') as f:
                cont = f.read()
        except OSError:
            # TODO info of no config
            return {
                    "dirs": {}
            }
        yml = yaml.safe_load(cont)
        return yml

    def parse(self):

        yml = self.read_conf()

        # rm = yml.get("remotes", {})
        dirs = yml["dirs"]

        for k in dirs:
            ups = self.parse_remote(k, dirs[k])
            sub_gitdir = self.sub_gitdir_fmt.format(dir=k)
            dirs[k] = {
                "dir": k,
                "upstream": {
                    "name": ups[0],
                    "url": ups[1],
                    "branch": ups[2],
                },
                "refhead": "refs/gift/sub/{dir}".format(dir=k),
                "sub_gitdir": sub_gitdir,
                "env": {
                    "GIT_DIR": pj(self.git_dir, sub_gitdir),
                    "GIT_WORK_TREE": pj(self.working_dir, k),
                    # "GIT_OBJECT_DIRECTORY": pj(self.git_dir, "objects"),
                },
                "bareenv": {
                    "GIT_DIR": pj(self.git_dir, sub_gitdir),
                },
            }

        return yml

    def _g(self, what="", bare=False):
        # TODO cwd
        # TODO git path
        if what == '':
            return Git(gitpath=self.gitpath,
                       gitdir=self.git_dir,
                       working_dir=self.working_dir)

        if isinstance(what, str):
            sb = self.conf["dirs"][what]
        else:
            sb = what
        if bare:
            return Git(gitpath=self.gitpath,
                       gitdir=sb["env"]["GIT_DIR"])
        else:
            return Git(gitpath=self.gitpath,
                       gitdir=sb["env"]["GIT_DIR"],
                       working_dir=sb["env"]["GIT_WORK_TREE"])

    def check_worktree(self, sb):
        self.try_init_sub_git(sb)
        self.try_init_sub_worktree(sb)

    def try_init_sub_git(self, sb):

        wtgpath = pj(self.git_dir, sb["sub_gitdir"])

        # TODO inited but not added remote, it will stop for ever

        bareenv = sb['bareenv']
        up = sb["upstream"]

        if not os.path.isdir(wtgpath):
            cmdx(self.gitpath, "init", "--bare", bareenv["GIT_DIR"])
        else:
            dd("gitdir exist:", wtgpath)

        g = self._g(sb, bare=True)
        u = g.remote_get(up["name"])
        if u is None:
            dd("remote not found, add:", up)
            g.remote_add(up["name"], up["url"])

        r = g.ref_get(up["name"] +'/'+ up["branch"])
        if r is None:
            dd("remote head not found:", up["name"] +'/'+ up["branch"])
            dd("need fetch")
            g.fetch(up["name"])


    def try_init_sub_worktree(self, sb):

        path = sb['env']["GIT_WORK_TREE"]
        if not os.path.isdir(path):
            os.makedirs(path, mode=0o755)

        g = self._g(sb)
        if g.ref_get("HEAD") is None:
            dd("HEAD not found:")
            g.checkout(sb['upstream']["branch"])


    def find_parent(self, subdir):

        working_dir = self.working_dir
        subdir = os.path.abspath(subdir)

        dd("working_dir:", working_dir)
        dd("subdir:", subdir)

        dd("conf:", self.conf["dirs"])

        while subdir != working_dir:
            reldir = subdir[len(working_dir) + 1:]
            dd("reldir:", reldir)
            if reldir in self.conf["dirs"]:
                return reldir, self.conf["dirs"][reldir]

            # trim last part.
            subdir, _ = os.path.split(subdir)
        else:
            return '', None

    def cmd(self, cmds):

        # If a command does not need to be run inside a git repo, delegate it
        # and quit.
        if cmds[0] == "init" and '--sub' not in cmds:
            # delegate to original git
            # TODO if user invoke "git --git-dir", original git still need env or else
            _, out, err = cmdx(self.gitpath, *cmds)
            display(out, err)
            return

        self.init_git_config()

        cmd, issub, cmds = self._arg_param(cmds)

        refs0 = self._get_head_refs()

        if self.in_git_dir:
            if issub:
                raise GiftError("--sub can not be used in git-dir:" + self.git_dir)
            else:
                # delegate to original git
                cmd_interactive(self.gitpath, *cmds, env=None)
        else:

            subdir = "."
            subdir, sb = self.find_parent(subdir)
            dd("subdir:", subdir, sb)


            env = None
            if sb is not None:
                self.check_worktree(sb)
                env = sb["env"]


            # TODO nested?
            if issub:

                if cmd == "init":
                    return self.x_init_sub(cmds)
                if cmd == "clone":
                    return self.x_clone_sub(cmds)
                elif cmd == 'commit':
                    return self.x_commit_sub(cmds)
                elif cmd == 'fetch':
                    return self.x_fetch_sub(cmds)
                elif cmd == 'merge':
                    return self.x_merge_sub(cmds)
                elif cmd == 'reset':
                    return self.x_reset_sub(cmds)

            # TODO run gift in a git-dir

            # delegate to original git
            cmd_interactive(self.gitpath, *cmds, env=env)

        refs1 = self._get_head_refs()
        if refs0 != refs1 and refs1 is not None:
            self._populate_ref(refs1)

    def _arg_param(self, cmds):

        cmd = cmds[0]
        cmds = cmds[1:]

        if '--' in cmds:
            i = cmds.index('--')
            args = cmds[:i]
        else:
            args = cmds

        issub = '--sub' in args
        if issub:
            cmds.remove('--sub')

        return cmd, issub, [cmd] + cmds

    def _get_head_refs(self):
        try:
            cont = cmd0(self.gitpath, "show", "HEAD:" + refsfn)
        except ProcError:
            return None

        try:
            return yaml.safe_load(cont)
        except Exception as e:
            print(repr(e))
            return None

    def x_clone_sub(self, cmds):

        # TODO test remove is gift clone --sub ssh://git@github.com/openacid/celeritasdb.wiki wiki
        # there is a "@" in it.
        #
        # TODO test ".gift" without "remotes"
        # TODO test clone --sub
        remote = cmds[1]
        subdir = cmds[2]
        # TODO overwrite existent conf?

        y = self.read_conf()
        y["dirs"][subdir] = remote
        cont = yaml.dump(y)
        write_file(self.confpath, cont)
        self.init_git_config()

        g = self._g()
        g.cmdx("add", self.confpath)
        g.cmdx("commit", self.confpath, "-m", "add sub repo: " + remote + " in "+ subdir)

        self.x_init_sub([])
        self.x_commit_sub([])


    def x_init_sub(self, cmds):
        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)

        try:
            cont = read_file(pj(self.working_dir, refsfn))
        except IOError:
            # TODO message
            pass
        else:
            refs = yaml.safe_load(cont)
            self._populate_ref(refs)

    def x_commit_sub(self, cmds):
        g = self._g()
        supertree = g.get_tree("HEAD")
        parent = g.commit_of("HEAD")
        refs = []
        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)
            supertree, commithash = self._add_sub(supertree, sb)
            refs.append([sb["dir"], commithash])

        refs = sorted(refs)
        cont = yaml.dump(refs)
        statep = pj(self.working_dir, refsfn)
        write_file(statep, cont)

        statehash = g.blob_new(statep)
        supertree = g.tree_add_obj(supertree, refsfn, statehash)

        newcommit = g.cmd0("commit-tree", "-p", parent, supertree, stdin="commit subdirs")
        g.cmdx("reset", newcommit)

        self._populate_ref(refs)

    def x_fetch_sub(self, cmds):
        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)
            _, out, err = cmdx(self.gitpath, "fetch", sb["upstream"]["name"], env=sb["env"])
            display(out, err)

    def x_merge_sub(self, cmds):
        # only ff-only allowed
        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)
            _, out, err = cmdx(self.gitpath, "merge", "--ff-only", env=sb["env"])
            display(out, err)

    def x_reset_sub(self, cmds):
        candidate_args = ['--soft',
                          '--mixed',
                          '-N',
                          '--hard',
                          '--merge',
                          '--keep',
                          '-q',
                          '--quiet', ]
        args = []
        for c in candidate_args:
            if c in cmds:
                args.append(c)

        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)
            _, out, err = cmdx(self.gitpath, "reset", *args, superref, env=sb["env"])
            display(out, err)

    def _populate_ref(self, refs):

        for subdir, hsh in refs:
            sb = self.conf["dirs"][subdir]

            try:
                # TODO test this
                cmdx(self.gitpath, "update-ref", superref, hsh, env=sb["env"])
            except ProcError:
                # TODO

                dd("can not update ref")

    def _add_sub(self, supertree, sb):
        g = self._g()

        g.cmdx("fetch", sb["env"]["GIT_DIR"], "+HEAD:" + sb["refhead"])

        sub_tree = g.get_tree(sb["refhead"])
        supertree = g.tree_add_obj(supertree, sb["dir"], sub_tree)

        return supertree, g.commit_of(sb["refhead"])


class Git(object):

    def __init__(self, gitpath=None, gitdir=None, working_dir=None, start_dir=None):
        self.gitpath = gitpath or "git"
        self.gitdir = gitdir
        self.working_dir = working_dir
        self.start_dir = start_dir

    def _env(self):
        env = {}
        if self.gitdir is not None:
            env["GIT_DIR"] = self.gitdir
        if self.working_dir is not None:
            env["GIT_WORK_TREE"] = self.working_dir

        return env

    def _opt(self, **kwargs):
        """
        Build env and cwd for a git command by specifying git-dir, working-dir etc.
        """
        opt = {
            "env": self._env(),
        }
        if self.start_dir is not None:
            opt["cwd"] = self.start_dir
        opt.update(kwargs)
        return opt

    # def url_valid(self, url):
    #     /(?:git|ssh|https?|git@[-\w.]+):(\/\/)?(.*?)(\.git)(\/?|\#[-\d\w._]+?)$/;

    def commit_of(self, ref):
        return self.cmd0("rev-parse", ref)

    def blob_new(self, f):
        return self.cmd0("hash-object", "-w", f)

    def checkout(self, branch):
        self.cmdx("checkout", branch)

    def fetch(self, name):
        self.cmdx("fetch", name)

    def get_tree(self, commit):
        return self.cmd0("rev-parse", commit + "^{tree}")

    def ref_get(self, name):
        try:
            return self.cmd0("rev-parse", "--verify", "--quiet", name)
        except ProcError:
            return None

    def remote_get(self, name):
        try:
            return self.cmd0("remote", "get-url", name)
        except ProcError:
            return None

    def remote_add(self, name, url):
        self.cmdx("remote", "add", name, url)

    def tree_items(self, treeish, name_only=False):
        args = []
        if name_only:
            args.append("--name-only")
        return self.cmdout("ls-tree", treeish, *args)

    def tree_add_obj(self, cur_tree, path, treeish):

        sep = os.path.sep

        itms = self.tree_items(cur_tree)

        if sep not in path:
            return self.tree_new(itms, path, treeish)

        # a/b/c -> a, b/c
        p0, left = path.split(sep, 1)
        p0item = self.tree_find_item(cur_tree, fn=p0, typ="tree")

        if p0item is None:

            newsubtree = treeish
            for p in reversed(left.split(sep)):
                newsubtree = self.tree_new([], p, newsubtree)
        else:

            subtree = p0item["object"]
            newsubtree = self.tree_add_obj(subtree, left, treeish)

        return self.tree_new(itms, p0, newsubtree)

    def tree_find_item(self, treeish, fn=None, typ=None):
        for itm in self.tree_items(treeish):
            itm = self.parse_tree_item(itm)
            if fn is not None and itm["fn"] != fn:
                continue
            if typ is not None and itm["type"] != typ:
                continue

            return itm
        return None

    def parse_tree_item(self, line):

        # git-ls-tree output:
        #     <mode> SP <type> SP <object> TAB <file>
        # This output format is compatible with what --index-info --stdin of git update-index expects.
        # When the -l option is used, format changes to
        #     <mode> SP <type> SP <object> SP <object size> TAB <file>
        # E.g.:
        # 100644 blob a668431ae444a5b68953dc61b4b3c30e066535a2    imsuperman
        # 040000 tree a668431ae444a5b68953dc61b4b3c30e066535a2    foo

        p, fn = line.split("\t", 1)

        elts = p.split(" ")
        rst = {
            "mode": elts[0],
            "type": elts[1],
            "object": elts[2],
            "fn": fn,
        }
        if len(elts) == 4:
            rst["size"] = elts[3]

        return rst

    def tree_new(self, itms, name, obj):

        typ = self.obj_type(obj)
        item_fmt = "{mode} {typ} {object}\t{name}"

        newitems = [x for x in itms
                    if self.parse_tree_item(x)["fn"] != name]

        # add a new item
        if typ == 'tree':
            mode = "040000"
        else:
            mode = "100644"
        itm = item_fmt.format(mode=mode,
                              typ=typ,
                              object=obj,
                              name=name
                              )
        newitems.append(itm)
        new_treeish = self.cmd0("mktree", stdin="\n".join(newitems))
        return new_treeish

    def obj_type(self, obj):
        return self.cmd0("cat-file", "-t", obj)

    def cmd0(self, *args, **kwargs):
        return cmd0(self.gitpath, *args, **self._opt(**kwargs))

    def cmdout(self, *args, **kwargs):
        return cmdout(self.gitpath, *args, **self._opt(**kwargs))

    def cmdx(self, *args, **kwargs):
        return cmdx(self.gitpath, *args, **self._opt(**kwargs))


# commit = cmd0(origit, "commit-tree", newtree)

# utils


class ProcError(Exception):

    def __init__(self, returncode, out, err, cmd, arguments, options):

        super(ProcError, self).__init__(returncode,
                                        out,
                                        err,
                                        cmd,
                                        arguments,
                                        options)

        self.returncode = returncode
        self.out = out
        self.err = err
        self.command = cmd
        self.arguments = arguments
        self.options = options

    def __str__(self):
        s = [str(self.command) + " " + str(self.arguments),
             "options: " + str(self.options),
             "exit code: " + str(self.returncode)]

        for l in self.out:
            s.append(l)

        for l in self.err:
            s.append(l)
        return "\n".join(s)

    def __repr__(self):
        s = [str(self.command) + " " + str(self.arguments),
             "options: " + str(self.options),
             "exit code: " + str(self.returncode)]
        for l in self.out:
            s.append(l)

        for l in self.err:
            s.append(l)
        return "\n".join(s)


def cmd0(cmd, *arguments, **options):
    """
    Similar to cmdx, but only return one line of stdout.
    """

    _, out, _ = cmdx(cmd, *arguments, **options)
    return out[0]


def cmdout(cmd, *arguments, **options):
    """
    Similar to cmdx, but only return stdout in a list.
    """

    _, out, _ = cmdx(cmd, *arguments, **options)
    return out


def cmdx(cmd, *arguments, **options):

    dd("command:", cmd, arguments, options)

    close_fds = options.get('close_fds', True)
    cwd = options.get('cwd', None)
    shell = options.get('shell', False)
    env = options.get('env', None)
    if env is not None:
        env = dict(os.environ, **env)
    stdin = options.get('stdin', None)

    arguments = [_bytes(x) for x in arguments]
    stdin = _bytes(stdin)

    subproc = subprocess.Popen([cmd] + list(arguments),
                               close_fds=close_fds,
                               shell=shell,
                               cwd=cwd,
                               env=env,
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE, )

    out, err = subproc.communicate(input=stdin)

    subproc.wait()

    out = _str(out)
    err = _str(err)

    if out != '':
        out = out.strip("\n").split("\n")
        for l in out:
            dd("stdout:", l)
    else:
        out = []

    if err != '':
        err = err.strip("\n").split("\n")
        for l in err:
            dd("stderr:", l)
    else:
        err = []

    if subproc.returncode != 0:
        raise ProcError(subproc.returncode, out, err, cmd, arguments, options)

    return subproc.returncode, out, err

def cmd_tty(cmd, *arguments, **options):

    # TODO doc

    # make a pseudo tty to cheat git

    dd("command:", cmd, arguments, options)

    close_fds = options.get('close_fds', True)
    shell = options.get('shell', False)
    cwd = options.get('cwd', None)
    env = options.get('env', None)
    if env is not None:
        env = dict(os.environ, **env)

    arguments = [_bytes(x) for x in arguments]

    master_fd, slave_fd = pty.openpty()
    err_master_fd, err_slave_fd = pty.openpty()

    subproc = subprocess.Popen([cmd] + list(arguments),
                               close_fds=close_fds,
                               shell=shell,
                               cwd=cwd,
                               env=env,
                               stdout=slave_fd,
                               stderr=err_slave_fd,
    )

    out = []
    err = []
    while subproc.poll() is None:
        r, _, _ = select.select([err_master_fd, master_fd], [], [], 0.01)
        if master_fd in r:
            o = os.read(master_fd, 10240)
            out.append(o)
        if err_master_fd in r:
            o = os.read(err_master_fd, 10240)
            err.append(o)

    out = b"".join(out)
    err = b"".join(err)

    out = _str(out)
    err = _str(err)

    if out != '':
        out = out.strip("\n").split("\n")
        for l in out:
            dd("stdout:", l)
    else:
        out = []

    if err != '':
        err = err.strip("\n").split("\n")
        for l in err:
            dd("stderr:", l)
    else:
        err = []

    if subproc.returncode != 0:
        raise ProcError(subproc.returncode, out, err, cmd, arguments, options)

    return subproc.returncode, out, err

def cmd_interactive(cmd, *arguments, **options):

    # interactive mode, delegate stdin to sub proc
    # and sub proc output directly to super proc stdout
    dd("command:", cmd, arguments, options)

    close_fds = options.get('close_fds', True)
    cwd = options.get('cwd', None)
    shell = options.get('shell', False)
    env = options.get('env', None)
    if env is not None:
        env = dict(os.environ, **env)

    arguments = [_bytes(x) for x in arguments]

    subproc = subprocess.Popen([cmd] + list(arguments),
                               close_fds=close_fds,
                               shell=shell,
                               cwd=cwd,
                               env=env,
    )

    subproc.communicate()
    subproc.wait()

    if subproc.returncode != 0:
        raise ProcError(subproc.returncode, [], [], cmd, arguments, options)

    return subproc.returncode, [], []


def display(out, err):
    for l in out:
        _out(1, l)
    for l in err:
        _out(2, l)


def read_file(path):
    with open(path, 'r') as f:
        return f.read()


def write_file(path, cont):
    with open(path, 'w') as f:
        f.write(cont)
        f.flush()
        os.fsync(f.fileno())


def _bytes(s):
    if isinstance(s, bytes):
        return s
    if isinstance(s, str):
        return bytes(s, defenc)
    return bytes(str(s), defenc)


def _str(bs):
    if isinstance(bs, bytes):
        return bs.decode(defenc, 'surrogateescape')
    return bs


def git_args():
    args = sys.argv[1:]
    opt = {
        "startpath": ".",
        "confkv": [],
        "paging": False,
        "no_replace_objects": False,
        "bare": False,
        "git_dir": None,
        "work_tree": None,
        "namespace": None,
        "super_prefix": None,
    }
    giftopt = {
        "verbose": False,
        "gitpath": None,
    }

    while True:
        arg = args.pop(0)

        if arg == '--version':
            cmd_ver()
            return
        if arg == '--help':
            cmd_help()
            return
        if arg == '-C':
            opt["startpath"] = args.pop(0)
            continue
        if arg == '-c':
            opt["confkv"].append(args.pop(0))
            continue
        # if arg == '--exec-path[=<path>]':
        if arg.startswith('--exec-path='):
            # TODO ignored
            continue
        if arg == '--html-path':
            cmd_html_path()
            return
        if arg == '--man-path':
            cmd_man_path()
            return
        if arg == '--info-path':
            cmd_info_path()
            return
        if arg in ('-p', '--paginate'):
            opt["paging"] = True
            continue
        if arg == '--no-pager':
            opt["paging"] = False
            continue

        if arg == '--no-replace-objects':
            opt["no_replace_objects"] = True
            continue

        if arg == '--bare':
            opt["bare"] = True
            continue

        if arg.startswith('--git-dir='):
            opt["git_dir"] = arg.split('=', 1)[1]
            continue

        if arg.startswith('--work-tree='):
            opt["work_tree"] = arg.split('=', 1)[1]
            continue

        if arg.startswith('--namespace='):
            opt["namespace"] = arg.split('=', 1)[1]
            continue
        if arg.startswith('--super-prefix='):
            opt["super_prefix"] = arg.split('=', 1)[1]
            continue

        if arg == '--gift-verbose':
            giftopt["verbose"] = True
            continue

        if arg.startswith('--git='):
            giftopt["gitpath"] = arg.split('=', 1)[1]
            continue

        break

    # push back
    cmds = [arg] + args
    return opt, giftopt, cmds


if __name__ == "__main__":
    opt, giftopt, cmds = git_args()
    dd("opt:", opt)
    dd("cmds:", cmds)
    # TODO test gitpath
    gift = Gift(".", opt, gitpath=giftopt["gitpath"])

    if giftopt["verbose"]:
        verbose = True

    try:
        gift.cmd(cmds)
    except ProcError as e:
        for l in e.out:
            _out(1, l)
        for l in e.err:
            _out(2, l)
        sys.exit(e.returncode)
    except GiftError as e:
        for l in e.out:
            _out(1, l)
        for l in e.err:
            _out(2, l)
        sys.exit(e.returncode)

