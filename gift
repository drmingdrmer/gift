#!/usr/bin/env python3
# coding: utf-8

import inspect
import os
import sys

import yaml

import pykit3proc
from pykit3proc import CalledProcessError

if hasattr(sys, 'getfilesystemencoding'):
    defenc = sys.getfilesystemencoding()
if defenc is None:
    defenc = sys.getdefaultencoding()

version = '0.1.0'
conffn = ".gift"
refsfn = ".gift-refs"
superref = "refs/remotes/super/head"

verbose = False
# verbose = True


def dd(*msg):
    if not verbose:
        return
    os.write(2, b">>> ")
    for m in msg:
        os.write(2, _bytes(m))
        os.write(2, b" ")
    os.write(2, b"\n")


def _out(f, line):
    os.write(f, _bytes(line))
    os.write(f, b"\n")


def pj(*args):
    return os.path.join(*args)


def pabs(*args):
    p = os.path.abspath(pj(*args))
    return os.path.normpath(p)


class GiftError(Exception):
    def __init__(self, msg):
        super(GiftError, self).__init__(msg)
        self.returncode = 2
        self.out = []
        self.err = [msg]


class Gift(object):
    """
    """

    # inside gitdir:
    sub_gitdir_fmt = "gift/subdir/{dir}"

    def __init__(self, opt):
        self.opt = opt
        if opt.get('exec_path') is None:
            self.gitpath = 'git'
        else:
            self.gitpath = pj(opt['exec_path'], 'git')
        self.in_git_dir = False

        # When multiple -C options are given, each subsequent non-absolute -C
        # <path> is interpreted relative to the preceding -C <path>.

        st = pabs(".")
        for p in opt['startpath']:
            st = self._init_path(st, p)

        self.startpath = st
        self.cwd = self.startpath

        self.git_dir = self._init_path(self.startpath, opt['git_dir'])
        self.working_dir = self._init_path(self.startpath, opt['work_tree'])

    def _get_super_opt(self):
        opt = {
            'cwd': self.cwd,
            'env': {
            }
        }
        if self.git_dir is not None:
            opt['env']['GIT_DIR'] = self.git_dir
        if self.working_dir is not None:
            opt['env']['GIT_WORK_TREE'] = self.working_dir
        return opt

    def _init_path(self, base, p):
        if p is None:
            return None
        if os.path.isabs(p):
            return p

        if base is None:
            return pabs(p)

        return pabs(base, p)

    def init_git_config(self):

        git_dir_specified = self.git_dir is not None

        if self.git_dir is None:
            self.git_dir = cmd0(self.gitpath, "rev-parse", "--git-dir", cwd=self.cwd)
            dd("git_dir:", self.git_dir)
            self.git_dir = pabs(self.git_dir)

        dd("git_dir:", self.git_dir)

        if (self.cwd.startswith(self.git_dir + '/')
                or self.git_dir == self.cwd):
            self.in_git_dir = True

        if self.in_git_dir:
            return

        # git rev-parse --show-toplevel:
        # - With --git-dir=xx, it always returns current dir.
        # - Without --git-dir=xx, it might fail if cwd is not in a git repo
        if git_dir_specified:
            if self.working_dir is None:
                self.working_dir = self.cwd
            else:
                pass
        else:
            if self.working_dir is None:
                # TODO test non git dir
                self.working_dir = cmd0(self.gitpath, "rev-parse", "--show-toplevel", cwd=self.cwd)

        # TODO test working_dir
        dd("working_dir:", self.working_dir)

        self.confpath = self.working_dir + '/' + conffn
        self.conf = self.parse()

    def parse_remote(self, subdir, remo):
        elts = remo.rsplit("@", 1)
        return ["origin", elts[0], elts[1]]

    def read_conf(self):
        try:
            with open(self.confpath, 'r') as f:
                cont = f.read()
        except OSError:
            # TODO info of no config
            return {
                "dirs": {}
            }
        yml = yaml.safe_load(cont)
        return yml

    def parse(self):

        yml = self.read_conf()

        # rm = yml.get("remotes", {})
        dirs = yml["dirs"]

        for k in dirs:
            ups = self.parse_remote(k, dirs[k])
            sub_gitdir = self.sub_gitdir_fmt.format(dir=k)
            dirs[k] = {
                "dir": k,
                "upstream": {
                    "name": ups[0],
                    "url": ups[1],
                    "branch": ups[2],
                },
                "refhead": "refs/gift/sub/{dir}".format(dir=k),
                "sub_gitdir": sub_gitdir,
                "env": {
                    "GIT_DIR": pj(self.git_dir, sub_gitdir),
                    "GIT_WORK_TREE": pj(self.working_dir, k),
                    # "GIT_OBJECT_DIRECTORY": pj(self.git_dir, "objects"),
                },
                "bareenv": {
                    "GIT_DIR": pj(self.git_dir, sub_gitdir),
                },
            }

        return yml

    def _g(self, what="", bare=False):
        # TODO cwd
        if what == '':
            return Git(gitpath=self.gitpath,
                       gitdir=self.git_dir,
                       working_dir=self.working_dir)

        if isinstance(what, str):
            sb = self.conf["dirs"][what]
        else:
            sb = what
        if bare:
            return Git(gitpath=self.gitpath,
                       gitdir=sb["env"]["GIT_DIR"])
        else:
            return Git(gitpath=self.gitpath,
                       gitdir=sb["env"]["GIT_DIR"],
                       working_dir=sb["env"]["GIT_WORK_TREE"])

    def check_worktree(self, sb):
        self.try_init_sub_git(sb)
        self.try_init_sub_worktree(sb)

    def try_init_sub_git(self, sb):

        wtgpath = pj(self.git_dir, sb["sub_gitdir"])

        bareenv = sb['bareenv']
        up = sb["upstream"]

        if not os.path.isdir(wtgpath):
            cmdx(self.gitpath, "init", "--bare", bareenv["GIT_DIR"])
        else:
            dd("gitdir exist:", wtgpath)

        g = self._g(sb, bare=True)
        u = g.remote_get(up["name"])
        if u is None:
            dd("remote not found, add:", up)
            g.remote_add(up["name"], up["url"])

        r = g.ref_get(up["name"] + '/' + up["branch"])
        if r is None:
            dd("remote head not found:", up["name"] + '/' + up["branch"])
            dd("need fetch")
            g.fetch(up["name"])

    def try_init_sub_worktree(self, sb):

        path = sb['env']["GIT_WORK_TREE"]
        if not os.path.isdir(path):
            os.makedirs(path, mode=0o755)

        g = self._g(sb)
        if g.ref_get("HEAD") is None:
            dd("HEAD not found:")
            g.checkout(sb['upstream']["branch"])

    def get_subrepo_config(self, subdir):

        # TODO test subdir not in working_dir?
        working_dir = self.working_dir
        subdir = os.path.abspath(subdir)

        dd("working_dir:", working_dir)
        dd("subdir:", subdir)

        rel = os.path.relpath(subdir, working_dir)
        if rel.startswith('..'):
            dd("subdir is not in working_dir")
            return '', None

        dd("conf:", self.conf["dirs"])

        while rel != '':
            dd("reldir:", rel)
            if rel in self.conf["dirs"]:
                return rel, self.conf["dirs"][rel]

            # trim last part.
            rel, _ = os.path.split(rel)
        else:
            return '', None

    def simple_cmd(self, cmds):
        cmd = cmds[0]
        if cmd == '--version':
            _out(1, "gift version " + version)
            self.delegate(['--version'], env=None)
        elif cmd == '--help':
            self.delegate(['--help'], env=None)
            lines = [
                "",
                "Gift extended command:",
                "",
                "gift clone --sub <url>@<branch> <dir>",
                "    Add a sub-repo to <dir> by clone it from <url>, and checkout <branch>",
                "",
                "gift commit --sub",
                "    Add all sub-repo to super-repo and commit",
                "",
            ]
            # TODO finish them
            for l in lines:
                _out(1, l)
        elif cmd in ('--exec-path',
                     '--man-path',
                     '--info-path',
                     '--html-path',
                     ):
            self.delegate([cmd])

    def cmd(self, cmds):

        dd("gift cmd:", cmds)

        # If a command does not need to be run inside a git repo, delegate it
        # and quit.
        if cmds[0] == "init" and '--sub' not in cmds:
            # delegate to original git
            # TODO if user invoke "git --git-dir", original git still need env or else
            _, out, err = cmdx(self.gitpath, *cmds)
            display(out, err)
            return

        self.init_git_config()

        cmd, issub, cmds = self._arg_param(cmds)

        refs0 = self._get_head_refs()

        if self.in_git_dir:
            if issub:
                raise GiftError("--sub can not be used in git-dir:" + self.git_dir)
            else:
                self.delegate(cmds, **self._get_super_opt())
        else:

            subdir = self.cwd
            subdir, sb = self.get_subrepo_config(subdir)
            dd("subdir:", subdir, sb)

            if sb is not None:
                self.check_worktree(sb)

            # TODO nested?
            if issub:

                if cmd == "init":
                    return self.x_init_sub(cmds)
                if cmd == "clone":
                    return self.x_clone_sub(cmds)
                elif cmd == 'commit':
                    return self.x_commit_sub(cmds)
                elif cmd == 'fetch':
                    return self.x_fetch_sub(cmds)
                elif cmd == 'merge':
                    return self.x_merge_sub(cmds)
                elif cmd == 'reset':
                    return self.x_reset_sub(cmds)

            if sb is not None:
                self.delegate(cmds, env=sb['env'], cwd=self.cwd)
            else:
                # TODO run gift in a git-dir
                self.delegate(cmds, **self._get_super_opt())

        refs1 = self._get_head_refs()
        if refs0 != refs1 and refs1 is not None:
            self._populate_ref(refs1)

    def delegate(self, cmds, cwd=None, env=None):
        # delegate to original git
        opts = self.make_opt()
        cmd_interactive(self.gitpath, *opts, *cmds, cwd=cwd, env=env)

    def make_opt(self):
        rst = []
        for kv in self.opt['confkv']:
            rst.append('-c')
            rst.append(kv)

        if self.opt['paging'] is not None:
            if self.opt['paging']:
                rst.append('--paginate')
            else:
                rst.append('--no-pager')

        return rst

    def _arg_param(self, cmds):

        cmd = cmds[0]
        cmds = cmds[1:]

        if '--' in cmds:
            i = cmds.index('--')
            args = cmds[:i]
        else:
            args = cmds

        issub = '--sub' in args
        if issub:
            cmds.remove('--sub')

        return cmd, issub, [cmd] + cmds

    def _get_head_refs(self):
        g = self._g()
        try:
            # TODO should not cmd0
            cont = g.cmd0("show", "HEAD:" + refsfn)
        except CalledProcessError:
            return None

        try:
            return yaml.safe_load(cont)
        except Exception as e:
            print(repr(e))
            return None

    def x_clone_sub(self, cmds):

        # TODO test remove is gift clone --sub ssh://git@github.com/openacid/celeritasdb.wiki wiki
        # there is a "@" in it.
        #
        # TODO test ".gift" without "remotes"
        # TODO test clone --sub
        remote = cmds[1]
        subdir = cmds[2]
        # TODO overwrite existent conf?

        y = self.read_conf()
        y["dirs"][subdir] = remote
        cont = yaml.dump(y, default_flow_style=False)
        write_file(self.confpath, cont)
        self.init_git_config()

        g = self._g()
        g.cmdx("add", self.confpath)
        g.cmdx("commit", self.confpath, "-m", "add sub repo: " + remote + " in " + subdir)

        self.x_init_sub([])
        self.x_commit_sub([])

    def x_init_sub(self, cmds):
        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)

        try:
            cont = read_file(pj(self.working_dir, refsfn))
        except IOError:
            # TODO message
            pass
        else:
            refs = yaml.safe_load(cont)
            self._populate_ref(refs)

    def x_commit_sub(self, cmds):
        g = self._g()
        supertree = g.get_tree("HEAD")
        parent = g.commit_of("HEAD")
        refs = []
        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)
            supertree, commithash = self._add_sub(supertree, sb)
            refs.append([sb["dir"], commithash])

        refs = sorted(refs)
        cont = yaml.dump(refs, default_flow_style=False)
        statep = pj(self.working_dir, refsfn)
        write_file(statep, cont)

        statehash = g.blob_new(statep)
        supertree = g.tree_add_obj(supertree, refsfn, statehash)

        newcommit = g.cmd0("commit-tree", "-p", parent, supertree, input="commit subdirs")
        g.cmdx("reset", newcommit)

        self._populate_ref(refs)

    def x_fetch_sub(self, cmds):
        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)
            _, out, err = cmdx(self.gitpath, "fetch", sb["upstream"]["name"], env=sb["env"])
            display(out, err)

    def x_merge_sub(self, cmds):
        # only ff-only allowed
        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)
            _, out, err = cmdx(self.gitpath, "merge", "--ff-only", env=sb["env"])
            display(out, err)

    def x_reset_sub(self, cmds):
        candidate_args = ['--soft',
                          '--mixed',
                          '-N',
                          '--hard',
                          '--merge',
                          '--keep',
                          '-q',
                          '--quiet', ]
        args = []
        for c in candidate_args:
            if c in cmds:
                args.append(c)

        for sub in self.conf["dirs"]:
            sb = self.conf["dirs"][sub]
            self.check_worktree(sb)
            _, out, err = cmdx(self.gitpath, "reset", *args, superref, env=sb["env"])
            display(out, err)

    def _populate_ref(self, refs):

        for subdir, hsh in refs:
            sb = self.conf["dirs"][subdir]

            try:
                # TODO test this
                cmdx(self.gitpath, "update-ref", superref, hsh, env=sb["env"])
            except CalledProcessError:
                # TODO

                dd("can not update ref")

    def _add_sub(self, supertree, sb):
        g = self._g()

        g.cmdx("fetch", sb["env"]["GIT_DIR"], "+HEAD:" + sb["refhead"])

        sub_tree = g.get_tree(sb["refhead"])
        supertree = g.tree_add_obj(supertree, sb["dir"], sub_tree)

        return supertree, g.commit_of(sb["refhead"])


class Git(object):

    def __init__(self, gitpath=None, gitdir=None, working_dir=None, start_dir=None):
        self.gitpath = gitpath or "git"
        self.gitdir = gitdir
        self.working_dir = working_dir
        self.start_dir = start_dir

    def _env(self):
        env = {}
        if self.gitdir is not None:
            env["GIT_DIR"] = self.gitdir
        if self.working_dir is not None:
            env["GIT_WORK_TREE"] = self.working_dir

        return env

    def _opt(self, **kwargs):
        """
        Build env and cwd for a git command by specifying git-dir, working-dir etc.
        """
        opt = {
            "env": self._env(),
        }
        if self.start_dir is not None:
            opt["cwd"] = self.start_dir
        opt.update(kwargs)
        return opt

    def commit_of(self, ref):
        return self.cmd0("rev-parse", ref)

    def blob_new(self, f):
        return self.cmd0("hash-object", "-w", f)

    def checkout(self, branch):
        self.cmdx("checkout", branch)

    def fetch(self, name):
        self.cmdx("fetch", name)

    def get_tree(self, commit):
        return self.cmd0("rev-parse", commit + "^{tree}")

    def ref_get(self, name):
        try:
            return self.cmd0("rev-parse", "--verify", "--quiet", name)
        except CalledProcessError:
            return None

    def remote_get(self, name):
        try:
            return self.cmd0("remote", "get-url", name)
        except CalledProcessError:
            return None

    def remote_add(self, name, url):
        self.cmdx("remote", "add", name, url)

    def tree_items(self, treeish, name_only=False):
        args = []
        if name_only:
            args.append("--name-only")
        return self.cmdout("ls-tree", treeish, *args)

    def tree_add_obj(self, cur_tree, path, treeish):

        sep = os.path.sep

        itms = self.tree_items(cur_tree)

        if sep not in path:
            return self.tree_new(itms, path, treeish)

        # a/b/c -> a, b/c
        p0, left = path.split(sep, 1)
        p0item = self.tree_find_item(cur_tree, fn=p0, typ="tree")

        if p0item is None:

            newsubtree = treeish
            for p in reversed(left.split(sep)):
                newsubtree = self.tree_new([], p, newsubtree)
        else:

            subtree = p0item["object"]
            newsubtree = self.tree_add_obj(subtree, left, treeish)

        return self.tree_new(itms, p0, newsubtree)

    def tree_find_item(self, treeish, fn=None, typ=None):
        for itm in self.tree_items(treeish):
            itm = self.parse_tree_item(itm)
            if fn is not None and itm["fn"] != fn:
                continue
            if typ is not None and itm["type"] != typ:
                continue

            return itm
        return None

    def parse_tree_item(self, line):

        # git-ls-tree output:
        #     <mode> SP <type> SP <object> TAB <file>
        # This output format is compatible with what --index-info --stdin of git update-index expects.
        # When the -l option is used, format changes to
        #     <mode> SP <type> SP <object> SP <object size> TAB <file>
        # E.g.:
        # 100644 blob a668431ae444a5b68953dc61b4b3c30e066535a2    imsuperman
        # 040000 tree a668431ae444a5b68953dc61b4b3c30e066535a2    foo

        p, fn = line.split("\t", 1)

        elts = p.split(" ")
        rst = {
            "mode": elts[0],
            "type": elts[1],
            "object": elts[2],
            "fn": fn,
        }
        if len(elts) == 4:
            rst["size"] = elts[3]

        return rst

    def tree_new(self, itms, name, obj):

        typ = self.obj_type(obj)
        item_fmt = "{mode} {typ} {object}\t{name}"

        newitems = [x for x in itms
                    if self.parse_tree_item(x)["fn"] != name]

        # add a new item
        if typ == 'tree':
            mode = "040000"
        else:
            mode = "100644"
        itm = item_fmt.format(mode=mode,
                              typ=typ,
                              object=obj,
                              name=name
                              )
        newitems.append(itm)
        new_treeish = self.cmd0("mktree", input="\n".join(newitems))
        return new_treeish

    def obj_type(self, obj):
        return self.cmd0("cat-file", "-t", obj)

    def cmd0(self, *args, **kwargs):
        return cmd0(self.gitpath, *args, **self._opt(**kwargs))

    def cmdout(self, *args, **kwargs):
        return cmdout(self.gitpath, *args, **self._opt(**kwargs))

    def cmdx(self, *args, **kwargs):
        return cmdx(self.gitpath, *args, **self._opt(**kwargs))


def cmd0(cmd, *arguments, **options):
    dd("cmd0:", cmd, arguments, options)

    _, out, _ = cmdx(cmd, *arguments, **options)
    dd("cmd0: out:", out)
    return out[0]


def cmdout(cmd, *arguments, **options):
    dd("cmdout:", cmd, arguments, options)

    _, out, _ = cmdx(cmd, *arguments, **options)
    dd("cmdout: out:", out)
    return out


def cmdx(cmd, *arguments, **options):
    dd("cmdx:", cmd, arguments, options)

    stack = inspect.stack()[1:]
    for i, (frame, path, ln, func, line, xx) in enumerate(stack):
        dd("stack:", ln, func, line, xx)

    options['check'] = True
    code, out, err = pykit3proc.command(cmd, *arguments, **options)
    out = out.splitlines()
    err = err.splitlines()
    return code, out, err


def cmd_tty(cmd, *arguments, **options):
    dd("cmd_tty:", cmd, arguments, options)
    options['tty'] = True
    return cmdx(cmd, *arguments, **options)


def cmd_interactive(cmd, *arguments, **options):
    # interactive mode, delegate stdin to sub proc
    dd("cmd_interactive:", cmd, arguments, options)
    options['capture'] = False
    return cmdx(cmd, *arguments, **options)


def display(out, err):
    for l in out:
        _out(1, l)
    for l in err:
        _out(2, l)


def read_file(path):
    with open(path, 'r') as f:
        return f.read()


def write_file(path, cont):
    with open(path, 'w') as f:
        f.write(cont)
        f.flush()
        os.fsync(f.fileno())


def _bytes(s):
    if isinstance(s, bytes):
        return s
    if isinstance(s, str):
        return bytes(s, defenc)
    return bytes(str(s), defenc)


def git_args():
    args = sys.argv[1:]
    opt = {
        "startpath": [],
        "confkv": [],
        "paging": None,
        "no_replace_objects": False,
        "bare": False,
        "git_dir": None,
        "work_tree": None,
        "namespace": None,
        "super_prefix": None,
        "exec_path": None,
    }
    giftopt = {
        "simple_cmd": None,
        "verbose": False,
    }

    cmds = args
    while len(args) > 0:
        arg = args.pop(0)

        if arg in ('--version',
                   '--help',
                   '--html-path',
                   '--info-path',
                   '--man-path',
                   '--exec-path',
                   ):
            giftopt['simple_cmd'] = arg
            continue

        if arg == '-C':
            opt["startpath"].append(args.pop(0))
            continue
        if arg == '-c':
            opt["confkv"].append(args.pop(0))
            continue
        if arg.startswith('--exec-path='):
            opt["exec_path"] = arg.split('=', 1)[1]
            continue
        if arg in ('-p', '--paginate'):
            opt["paging"] = True
            continue
        if arg == '--no-pager':
            opt["paging"] = False
            continue

        if arg == '--no-replace-objects':
            # TODO
            opt["no_replace_objects"] = True
            continue

        if arg == '--bare':
            # TODO
            opt["bare"] = True
            continue

        if arg.startswith('--git-dir='):
            opt["git_dir"] = arg.split('=', 1)[1]
            continue

        if arg.startswith('--work-tree='):
            opt["work_tree"] = arg.split('=', 1)[1]
            continue

        if arg.startswith('--namespace='):
            # TODO
            opt["namespace"] = arg.split('=', 1)[1]
            continue
        if arg.startswith('--super-prefix='):
            # TODO
            opt["super_prefix"] = arg.split('=', 1)[1]
            continue

        if arg == '--gift-verbose':
            giftopt["verbose"] = True
            continue

        # push back
        cmds = [arg] + args
        break

    return opt, giftopt, cmds


if __name__ == "__main__":
    opt, giftopt, cmds = git_args()
    dd("opt:", opt)
    dd("cmds:", cmds)
    # TODO need to pass opt to delegated command
    # TODO test change remote/up['branch'] then init again.
    gift = Gift(opt)

    if giftopt["verbose"]:
        verbose = True

    if cmds == [] and giftopt['simple_cmd'] is None:
        gift.simple_cmd(['--help'])
        sys.exit(1)

    if cmds != [] and cmds[0] == 'gift-debug':
        _out(1, ' '.join(cmds))
        _out(1, yaml.dump(opt, default_flow_style=False))
        _out(1, yaml.dump(giftopt, default_flow_style=False))
        _out(1, "evaluated cwd: " + str(gift.cwd))
        _out(1, "evaluated git_dir: " + str(gift.git_dir))
        _out(1, "evaluated working_dir: " + str(gift.working_dir))
        sys.exit(0)

    try:
        if giftopt['simple_cmd'] is not None:
            gift.simple_cmd([giftopt['simple_cmd']])
        else:
            gift.cmd(cmds)
    except CalledProcessError as e:
        display(e.out, e.err)
        sys.exit(e.returncode)
    except GiftError as e:
        display(e.out, e.err)
        sys.exit(e.returncode)
    except KeyboardInterrupt:
        _out(2, "user interrupted")
        sys.exit(1)
